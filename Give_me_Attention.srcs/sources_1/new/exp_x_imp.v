`timescale 1ns / 1ps

module exp_imp #(parameter bitw = 16, bitw_out = 16)(input clk, [bitw-1:0] x,
output reg [2*bitw_out+1:0] y , output reg val); // 2-bits integer part and 30 bits fractional

//reg [bitw_out-1:0] lut_1 [10:0]; // 4-bits for integer part
//reg [bitw_out-1 : 0] lut_2 [15:0]; // 4-bits for most significant bits of fractional part

reg [15:0] inv_ln2 = 16'hB8AA; //1-integer bit and 15 fractional bits
reg [bitw_out-1:0] op1;
reg [bitw_out-1:0] op2;

//always @(*) begin
//    lut_1[0] = 16'h8000; // 1-integer bit and 15 fractional bits // 1.0
//    lut_1[1] = 16'b0010111100010110; // 0.36787944
//    lut_1[2] = 16'b0001000101010010; // 0.1353352832
//    lut_1[3] = 16'b0000011001011111; // 0.0497870683
//    lut_1[4] = 16'b0000001001011000; // 0.018315638888
//    lut_1[5] = 16'b0000000011011100; // 0.006737947
//    lut_1[6] = 16'b0000000001010001; // 0.002478752176
//    lut_1[7] = 16'b0000000000011101; // 0.0009118819655
//    lut_1[8] = 16'b0000000000001011; // 0.00033546262790
//    lut_1[9] = 16'b0000000000000100; // 0.000123409804040
//    lut_1[10] = 16'b0000000000000001; // 0.00004534
//end

//always @(*) begin
//    lut_2[0] = 16'h8000; // 1-integer bit and 15 fractional bits // 1.0
//    lut_2[1] = 16'b0111100000111110; // 0.9394130628
//    lut_2[2] = 16'b0111000011110101; // 0.882496902585
//    lut_2[3] = 16'b0110101000011101; //  0.829029118180
//    lut_2[4] = 16'b0110001110101111; // 0.7788007830714
//    lut_2[5] = 16'b0101110110100101; // 0.731615662895
//    lut_2[6] = 16'b0101011111111001; // 0.687289278790972
//    lut_2[7] = 16'b0101001010100100; // 0.6456485264279
//    lut_2[8] = 16'b0100110110100010; // 0.6065306597126
//    lut_2[9] = 16'b0100100011101110; // 0.569782824731
//    lut_2[10] = 16'b0100000111101011; // 0.514994188459
//    lut_2[11] = 16'b0100000100101100; // 0.50915642060755
//    lut_2[12] = 16'b0011110100111001; // 0.47830819253408
//    lut_2[13] = 16'b0011100110000011; // 0.449328964117
//    lut_2[14] = 16'b0011011000000111; // 0.422105498392
//    lut_2[15] = 16'b0011001011000001; // 0.396531419075
//end

reg [bitw-1:0] x_new;
//reg [bitw-1:0] y_new;
wire [31:0] prod_1;
reg out_valid;
reg valid;

always @( posedge clk) begin
    x_new <= x;
    if(valid) begin
        y <= prod_1;
    end
    else begin
        y <= 0;
    end
end

always @(*) begin
    case(x_new[{bitw-1}: {bitw-4}])
        4'b0000: op1 = 16'h8000;
        4'b0001: op1 = 16'b0010111100010110;// 0.36787944
        4'b0010: op1 = 16'b0001000101010010; // 0.1353352832
        4'b0011: op1 = 16'b0000011001011111; // 0.0497870683
        4'b0100: op1 = 16'b0000001001011000; // 0.018315638888
        4'b0101: op1 = 16'b0000000011011100; // 0.006737947
        4'b0110: op1 = 16'b0000000001010001; // 0.002478752176
        4'b0111: op1 = 16'b0000000000011101; // 0.0009118819655
        4'b1000: op1 = 16'b0000000000001011; // 0.00033546262790
        4'b1001: op1 = 16'b0000000000000100; // 0.000123409804040
        4'b1010: op1 = 16'b0000000000000001; // 0.00004534
    endcase
    
    case(x_new[bitw-5:bitw-8])
        4'b0000: op2 = 16'h8000;
        4'b0001: op2 = 16'b0111100000111110; // 0.9394130628
        4'b0010: op2 = 16'b0111000011110101; // 0.882496902585
        4'b0011: op2 = 16'b0110101000011101; //  0.829029118180
        4'b0100: op2 = 16'b0110001110101111; // 0.7788007830714
        4'b0101: op2 = 16'b0101110110100101; // 0.731615662895
        4'b0110: op2 = 16'b0101011111111001; // 0.687289278790972
        4'b0111: op2 = 16'b0101001010100100; // 0.6456485264279
        4'b1000: op2 = 16'b0100110110100010; // 0.6065306597126
        4'b1001: op2 = 16'b0100100011101110; // 0.569782824731
        4'b1010: op2 = 16'b0100000111101011; // 0.514994188459
        4'b1011: op2 = 16'b0100000100101100; // 0.50915642060755
        4'b1100: op2 = 16'b0011110100111001; // 0.47830819253408
        4'b1101: op2 = 16'b0011100110000011; // 0.449328964117
        4'b1110: op2 = 16'b0011011000000111;// 0.422105498392
        4'b1111: op2 = 16'b0011001011000001; // 0.396531419075
    endcase
end

always @(*) begin
    if(x_new > 16'hb000) begin
        valid = 1'b0;
    end
    else begin
        valid = 1'b1;
    end
    val = valid;
end
mult_gen_0 multu (.CLK(clk),.A(op1),.B(op2),.P(prod_1));
//mult_gen_0 mult_1(.CLK(clk), .A(lut_1[x_new[15:12]]),.B(lut_2[x_new[11:8]]), .P(prod_1));
//mult_gen_0 mult_1(.CLK(clk), .A(lut_1[0]),.B(lut_2[2]), .P(prod_1));
endmodule

